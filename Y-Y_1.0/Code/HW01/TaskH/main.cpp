#include <iostream>
#include <cmath>
#include <vector>

/**
 * @brief Проверка на вхождение значения в интервал
 * 
 * @param point целевая точка
 * @param low левая граница интервала
 * @param high правая граница интервала
 * 
 * @return true, если point /in [low, high], иначе false
 * @note Функция не используется в решении (т.к. Гипотеза #1 не верна)
 */
bool isInInterval (int& point, int& low, int& high) {
    if (point < high && point > low)
        return true;
    else return false;
}

/**
 * @brief Решение задачи
 * 
 * @param a, b, n, m входные данные задачи
 * @return std::pair<int, int> интервал времени, либо пару {-1, -1}, если Т не права
 */
std::pair<int, int> solution(int& a, int& b, int& n, int& m) {
    /* Пока допустим, что Таня (далее Т) всегда права 
    */

    // Инициализация
    int a_min = 1 + (a + 1) * (n - 1); // или a*(n-1) + n
    int a_max = (a + 1) * n + a; // или a_min + 2 * a
    int b_min = 1 + (b + 1) * (m - 1);
    int b_max = (b + 1) * m + b;

    int minm = std::max(a_min, b_min);
    int maxm = std::min(a_max, b_max);

    std::pair<int, int> result = {minm, maxm};

    /*  Гипотеза #1: если возникает противоречие, значит Т сбилась со счета. Когда может возникать противоречие?
    Когда разница между элементами std::max() может вместить больше поездов, чем n или m.
    
    Нам достаточно считать сколько поездов может приехать в "разницу", т.к. поиск лишних поездов (когда Т насчитала больше)
    можно свести к обратной ситуации (когда Т насчитала меньше), только для другого пути.
    Это можно свести к следующему условию: 
        1) пересчитать a_min, ... , b_max с a+1 и b+1;
        2) новые значение a_min, ... , b_max попадают в прошлый интервал [minm; maxm]

    Гипотеза ложная (input: 1 3 3 2; desired output: 5 7; actual output: -1). Почему так получилось? Потому что посчитанный случай не единственный.
    В такой конфигурации возможны несколько путей развития событий, когда Т может увидеть 3 поезда на I пути, 2 поезда на II пути за 6 минут. Также, если
    считать иначе (поезд прибыл или нет при t=0), Т может посчитать на 1 поезд больше за те же 6 минут.

    Нам не важно, что могут существовать неверные временные комбинации приезжа поездов. Важно, что Т была права.

        Гипотеза #2: Т точно ошиблась, если самое оптимальное расположение поездов (то, когда мы считаем minm) больше, чем наихудшее расположение поездов (maxm).
    Т. е. if (minm > maxm) return -1;
    */

   if (minm > maxm)
   {
        return {-1, -1}; // Уникальное значение, которое не может быть достигнуто ни при каких a,b,n,m.
   }
   
    return result;
}

int main() {
    // Инициализация
    int a=0, b=0, n=0, m=0;
    std::cin >> a >> b >> n >> m;

    // Тело
    auto result = solution(a, b, n, m);

    if (result.first == -1)
    {
        std::cout << -1;
    } else std::cout << result.first << " " << result.second;

    return 0;
}