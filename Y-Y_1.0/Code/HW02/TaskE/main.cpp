#include <iostream>
#include <vector>
#include <map>
#include <tuple>
#include <typeinfo>

/**
 * @brief Решение задачи
 * 
 * @param seq Последовательность чисел
 * @return ответ задачи
 * 
 * @note Возможно не самое оптимальное решение, много циклов
 */
int solution(std::vector<int>& seq) {
    /*
    Трактиорист Василий помнит три факта:

    1) Число метров, на которое он метнул лепешку, оканчивалось на 5
    2) Один из победителей чемпионата метал лепешку до Василия
    3) Участник, метавший лепешку сразу после Василия, метнул ее на меньшее количество метров

    Будем считать, что участник соревнования занял k-е место, если ровно (k − 1) участников чемпионата метнули лепешку строго дальше, чем он.
    Какое максимально высокое место мог занять Василий?
    */

    /*
    Можно создать словарь, который будет содержать средний элемент и соседей. Тогда 
    1) мы строим словарь за O(N). Подходящий элемент это выполнение трех условий, причем 2 условие идет как "left >= mid" (надо захватить патовую ситуацию как в тесте 2);
    2) проходимся по словарю за O(K), K<N и ищем такую комбинацию, в которой max наибольший. 
    *) Также if left == mid, то декрементируем найденную позицию.

    Т.к. п.2) "один из победителей", нас удовлетворяет ситуация, если left меньше какого-то максимума (не обязательно вып. условия) в последовательности.
    */

    int place = -1;
    std::map<int, std::tuple<int, int, int>> dict;

    if (seq.size() < 3)
        return 0;

    // Шаг 1) Заполнение словаря
    int left, mid, right;
    for (int i = 1; i < seq.size()-1; i++) {
        left = seq[i-1];
        mid = seq[i];
        right = seq[i+1];

        if ((mid % 5 == 0) && (mid % 10 != 0))
            if (left >= mid)
                if (right < mid) {
                    //place = i;
                    dict[i] = {left, mid, right};
                }
    }

    if (dict.empty()) return 0;
    
    // Шаг 2) Проход про словарю и поиск max(mid), т.к. по условию №2 перед Василием стоит один из победителей (довольно жидкое условие)
    int max_pos = -1; // На самом деле минимальная. Но тут больше смысл "чем ближе к 1 месту, тем максимальнее"
    int max_left = -1;
    for (const auto [pos, tpl] : dict) {
        left = std::get<0>(tpl);
        if (left >= max_left) {
            max_pos = pos;
            max_left = left;
        }
    }

    // Корректировка на место в таблице лидеров
    int count = 0;
    mid = std::get<1>(dict[max_pos]);
    //mid = max_mid;
    for (int i = 0; i < seq.size(); i++) {
        if (seq[i] > mid || i == max_pos) // строго больше, т.к. даже если найдем совпадения, то все удовлетворяющие события уже были обработаны
            count++;
    }

    place = max_pos+1;
    //std::cout << "count: " << count << "; place: " << place << "\n";

    return count;
}

int main() {
    // Объявление переменных
    int n;
    std::vector<int> seq;
    
    std::cin >> n;
    int buff;
    for (int i = 0; i < n; i++)
    {
        std::cin >> buff;
        seq.push_back(buff);
    }
    /*
    std::vector<std::pair<int, std::vector<int>>> tests = {
                                                           {7, {10, 20, 15, 10, 30, 5, 1}},
                                                           {3, {15, 15, 10}},
                                                           {3, {10, 15, 20}},
                                                           {5, {625, 933, 175, 17, 241}}};
    for (auto [f, s] : tests)
        std::cout << "TEST " << f << ": " << solution(s) << std::endl;                                                        */

    std::cout << solution(seq);

    return 0;
}