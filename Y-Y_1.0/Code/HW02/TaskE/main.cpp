#include <iostream>
#include <vector>
#include <map>
#include <tuple>
#include <typeinfo>

/*
Трактиорист Василий помнит три факта:

1) Число метров, на которое он метнул лепешку, оканчивалось на 5
2) Один из победителей чемпионата метал лепешку до Василия
3) Участник, метавший лепешку сразу после Василия, метнул ее на меньшее количество метров

Будем считать, что участник соревнования занял k-е место, если ровно (k − 1) участников чемпионата метнули лепешку строго дальше, чем он.
Какое максимально высокое место мог занять Василий?
*/

/**
 * @brief Гипотеза №1, ломается на некоторых тестах
 * 
 * @param seq Последовательность чисел
 * @return ответ задачи
 * 
 * @note Ошибка в том, что поиск базируется на 1 условии, что не совсем верно. Может можно доделать, но O(K*N^2) при K<N и слишком сложное решение
 */
int solution1(std::vector<int>& seq) {
    /*
    Можно создать словарь, который будет содержать средний элемент и соседей. Тогда 
    1) мы строим словарь за O(N). Подходящий элемент это выполнение трех условий, причем 2 условие идет как "left >= mid" (надо захватить патовую ситуацию как в тесте 2);
    2) проходимся по словарю за O(K), K<N и ищем такую комбинацию, в которой max наибольший. 
    *) Также if left == mid, то декрементируем найденную позицию.

    Т.к. п.2) "один из победителей", нас удовлетворяет ситуация, если left меньше какого-то максимума (не обязательно вып. условия) в последовательности.
    */

    int place = -1;
    std::map<int, std::tuple<int, int, int>> dict;

    if (seq.size() < 3)
        return 0;

    // Шаг 1) Заполнение словаря
    int left, mid, right;
    for (int i = 1; i < seq.size()-1; i++) {
        left = seq[i-1];
        mid = seq[i];
        right = seq[i+1];

        if ((mid % 5 == 0) && (mid % 10 != 0))
            if (left >= mid)
                if (right < mid) {
                    //place = i;
                    dict[i] = {left, mid, right};
                }
    }

    if (dict.empty()) return 0;
    
    // Шаг 2) Проход про словарю и поиск max(mid), т.к. по условию №2 перед Василием стоит один из победителей (довольно жидкое условие)
    int max_pos = -1; // На самом деле минимальная. Но тут больше смысл "чем ближе к 1 месту, тем максимальнее"
    int max_left = -1;
    for (const auto [pos, tpl] : dict) {
        left = std::get<0>(tpl);
        if (left >= max_left) {
            max_pos = pos;
            max_left = left;
        }
    }

    // Корректировка на место в таблице лидеров
    int count = 0;
    mid = std::get<1>(dict[max_pos]);
    //mid = max_mid;
    for (int i = 0; i < seq.size(); i++) {
        if (seq[i] > mid || i == max_pos) // строго больше, т.к. даже если найдем совпадения, то все удовлетворяющие события уже были обработаны
            count++;
    }

    place = max_pos+1;
    //std::cout << "count: " << count << "; place: " << place << "\n";

    return count;
}

/**
 * @brief Гипотеза №2, верное решение
 * 
 * @param seq Последовательность чисел
 * @return решение задачи
 * 
 * @note Поиск наилучшего места Василия базируется на условии 2. "До Василия" != "сразу перед Василием"
 */
int solution2(const std::vector<int>& seq)
{
	int result = -1; // Наилучший скор Василия
	int max_value = seq[0];
	int curr_value = seq[1]; // Рассматриваем сразу триплет (tuple<int, int, int>) из элементов последовательности

    // Шаг 1) Вместо заполнения словаря, отбрасываем все значения слева от максимального и анализируем все, что справа:
	for (int i = 2; i < seq.size(); i++) {
		if (curr_value > max_value) {// true, если не выполняется условие 2
			max_value = curr_value;
			result = -1;
		} else if (seq[i] < curr_value && result < curr_value && curr_value%10 == 5) /* (условие №3 && условие №4 && условие №1) 
																					     условие №4: если уже был найден "предварительный победитель", ищем лучший результат Василия (нам же нужно макс место)*/
			result = curr_value;
			
		curr_value = seq[i];
	}
	
	// Шаг 2) Корректировка по таблице лидеров
	int place = 0;
	if (result != -1) {
		place = 1;
		for (int i = 0; i < seq.size(); i++)
			if (seq[i] > result)
				place += 1;
		return place;
	}
	
	return place;
}

int main() {
    // Объявление переменных
    int n;
    std::vector<int> seq;
    
    std::cin >> n;
    int buff;
    for (int i = 0; i < n; i++)
    {
        std::cin >> buff;
        seq.push_back(buff);
    }
    /*
    std::vector<std::pair<int, std::vector<int>>> tests = {
                                                           {7, {10, 20, 15, 10, 30, 5, 1}},
                                                           {3, {15, 15, 10}},
                                                           {3, {10, 15, 20}},
                                                           {5, {625, 933, 175, 17, 241}}};
    for (auto [f, s] : tests)
        std::cout << "TEST " << f << ": " << solution(s) << std::endl;                                                        */

    std::cout << solution2(seq);

    return 0;
}