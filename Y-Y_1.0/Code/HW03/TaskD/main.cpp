#include <iostream>
#include <memory>
#include <string>
#include <unordered_set>

int main() {
    std::unordered_set<std::string> result;
    std::string usr_str;
    
    while (std::cin >> usr_str) {
        result.insert(usr_str);
        //result.insert(move(usr_str));
    }

    std::cout << result.size() << '\n';

    return 0;
}

/*
    Без std::move
Если бы мы использовали просто result.insert(usr_str);, то строка usr_str была бы скопирована в контейнер. 
Эта копия создаётся с использованием конструктора копирования std::string, что требует выделения новой памяти и копирования данных из исходного объекта в новый.

    С std::move:
Когда мы используем std::move(usr_str), строка передаётся в контейнер с помощью конструктора перемещения std::string. 
В этом случае данные из usr_str перемещаются в новый объект без копирования. 
Сам объект usr_str после перемещения остаётся в валидном, но неопределённом состоянии (например, его внутренняя строка может стать пустой, но объект остаётся корректным). 
Это значительно эффективнее по времени и по памяти, так как не требуется выделять новую память и копировать данные, а просто передаётся владение уже существующими ресурсами (например, указателем на память, где хранится строка).

*/